// Package main демонстрирует, как использовать буферизированный канал в качестве
// семафора для ограничения количества одновременно выполняющихся горутин.
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	const maxConcurrency = 5 // Максимальное количество одновременно работающих воркеров.
	const numTasks = 10      // Общее количество задач для выполнения.

	// Создаем буферизированный канал. Размер буфера — это наш лимит конкурентности.
	// Канал будет действовать как семафор: каждая "пустая" ячейка в буфере — это
	// разрешение на запуск новой горутины. Мы используем `struct{}` в качестве типа,
	// так как он не занимает памяти и служит лишь сигналом.
	semaphore := make(chan struct{}, maxConcurrency)

	var wg sync.WaitGroup
	wg.Add(numTasks)

	fmt.Printf("Запускаем %d задач с максимальной конкурентностью %d...\n", numTasks, maxConcurrency)

	for i := 0; i < numTasks; i++ {
		// --- Шаг 1: "Захват" разрешения ---
		// Отправляем пустоту в канал. Эта операция заблокируется, если буфер канала
		// полон (т.е. если уже запущено `maxConcurrency` горутин), и будет ждать,
		// пока какая-либо из работающих горутин не освободит место.
		fmt.Printf("Задача %d: ожидание свободного слота...\n", i)
		semaphore <- struct{}{}
		fmt.Printf("Задача %d: слот получен, запуск воркера.\n", i)

		// Передаем `i` как аргумент, чтобы избежать проблемы с захватом переменной цикла.
		go func(workerID int) {
			defer wg.Done()

			// --- Шаг 2: "Освобождение" разрешения ---
			// `defer` гарантирует, что мы освободим слот в семафоре после завершения работы.
			// Чтение из канала освобождает одну ячейку в буфере, позволяя
			// следующей ожидающей задаче захватить ее и запуститься.
			defer func() {
				<-semaphore
				fmt.Printf("Воркер %d: работа завершена, слот освобожден.\n", workerID)
			}()

			// Имитация полезной работы.
			fmt.Printf("Воркер %d: начал работу...\n", workerID)
			time.Sleep(2 * time.Second)
		}(i)
	}

	// Ожидаем завершения всех 10 задач.
	wg.Wait()
	fmt.Println("Все задачи выполнены.")
}
