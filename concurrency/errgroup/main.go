// Package main демонстрирует использование `golang.org/x/sync/errgroup`.
//
// `errgroup` — это удобная обертка над `sync.WaitGroup`, которая упрощает
// управление группой горутин, выполняющих подзадачи.
//
// Ключевые преимущества:
// 1. Сбор ошибок: `Wait()` возвращает первую возникшую ошибку из любой горутины.
// 2. Отмена по контексту: При создании с `errgroup.WithContext` группа получает
//    контекст, который автоматически отменяется, как только одна из горутин
//    возвращает ошибку. Это позволяет остальным горутинам быстро прекратить работу.
package main

import (
	"context"
	"fmt"
	"time"

	"golang.org/x/sync/errgroup"
)

// worker — это функция, имитирующая работу, выполняемую в отдельной горутине.
// Она принимает ID, контекст errgroup и флаг, указывающий, должна ли она вернуть ошибку.
func worker(workerID int, egCtx context.Context, shouldFail bool) error {
	fmt.Printf("Воркер %d: запущен.\n", workerID)
	for j := 0; j < 10; j++ {
		// Критически важная проверка: перед выполнением очередной порции работы
		// необходимо проверять, не был ли отменен контекст.
		// Это позволяет горутине завершиться досрочно, если другая горутина уже вернула ошибку.
		select {
		case <-egCtx.Done():
			// Контекст отменен. Завершаем работу.
			fmt.Printf("Воркер %d: получил сигнал отмены. Завершение...\n", workerID)
			return egCtx.Err() // Возвращаем ошибку контекста.
		default:
			// Контекст не отменен, продолжаем работу.
		}

		// Имитация сбоя в одном из воркеров.
		if shouldFail && workerID == 1 && j == 3 {
			errorMessage := fmt.Errorf("воркер %d: произошла ошибка на итерации %d", workerID, j)
			fmt.Printf("!!! %s\n", errorMessage)
			return errorMessage
		}

		fmt.Printf("Воркер %d: выполняет шаг %d\n", workerID, j)
		time.Sleep(100 * time.Millisecond)
	}
	fmt.Printf("Воркер %d: успешно завершил всю работу.\n", workerID)
	return nil
}

func main() {
	fmt.Println("--- Сценарий 1: Все воркеры завершаются успешно ---")
	runScenario(false) // `false` означает, что никто не должен сбоить.

	fmt.Println("\n\n--- Сценарий 2: Один из воркеров возвращает ошибку ---")
	runScenario(true) // `true` означает, что один из воркеров сгенерирует ошибку.
}

func runScenario(fail bool) {
	// Создаем errgroup с контекстом, который будет отменен при первой ошибке.
	eg, egCtx := errgroup.WithContext(context.Background())
	numWorkers := 3

	for i := 0; i < numWorkers; i++ {
		// Правильный способ передачи переменной цикла в горутину.
		// Создаем копию `i`, чтобы каждая горутина получила свое уникальное значение.
		workerID := i
		shouldThisWorkerFail := fail

		// Запускаем горутину с помощью `eg.Go()`.
		eg.Go(func() error {
			// Вызываем нашего воркера. Любая ошибка, возвращенная отсюда,
			// будет поймана `eg.Wait()`.
			return worker(workerID, egCtx, shouldThisWorkerFail)
		})
	}

	// `eg.Wait()` блокирует выполнение до тех пор, пока все горутины не завершатся.
	// Он возвращает первую не-nil ошибку от любого из воркеров или nil, если все успешны.
	err := eg.Wait()

	if err != nil {
		fmt.Printf("\nРезультат: Группа завершилась с ошибкой: %v\n", err)
	} else {
		fmt.Println("\nРезультат: Все воркеры успешно завершили работу.")
	}
}
