// Package main демонстрирует комплексный паттерн конкуренции в Go, объединяя:
// - Каналы (channels) для потоковой передачи данных.
// - WaitGroup для ожидания завершения горутины.
// - Контекст (context) для graceful shutdown (грациозной остановки) по таймеру.
//
// Паттерн: Producer-Consumer с отменой по таймауту.
package main

import (
	"context"
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// producer генерирует случайные числа и отправляет их в канал.
// Он останавливается, когда контекст отменяется.
func producer(ctx context.Context, ch chan<- int, wg *sync.WaitGroup) {
	// `defer` выполняется в порядке LIFO (Last-In, First-Out).
	// 1. `wg.Done()` будет вызван вторым (последним), сигнализируя о полном завершении горутины.
	defer wg.Done()
	// 2. `close(ch)` будет вызван первым, сигнализируя потребителю, что данных больше не будет.
	// Этот порядок (сначала закрыть канал, потом сообщить WaitGroup) более надежен.
	defer close(ch)

	for {
		select {
		case <-ctx.Done():
			// Контекст был отменен (например, по таймауту), выходим из функции.
			fmt.Println("Продюсер: контекст отменен, завершаю работу.")
			// defer'ы будут вызваны здесь.
			return
		default:
			// Генерируем случайное число.
			n := rand.Intn(100)
			fmt.Printf("Продюсер: отправляю %d\n", n)

			// Отправляем значение в канал.
			ch <- n

			// Ждем некоторое время перед отправкой следующего числа.
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	// Инициализируем генератор случайных чисел.
	rand.Seed(time.Now().UnixNano())

	// Создаем контекст с таймаутом в 3 секунды.
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	// cancel() следует вызывать, чтобы освободить ресурсы, связанные с контекстом,
	// особенно в случаях, когда мы выходим из main раньше, чем контекст истечет.
	defer cancel()

	ch := make(chan int)
	var wg sync.WaitGroup

	// Увеличиваем счетчик WaitGroup на 1, так как мы запускаем одну горутину-продюсера.
	wg.Add(1)
	go producer(ctx, ch, &wg)

	// Потребитель: читаем значения из канала.
	fmt.Println("Потребитель: ожидаю данные...")
	// Цикл `for range` над каналом — это основной способ синхронизации здесь.
	// Он будет автоматически завершен, когда продюсер закроет канал `ch`.
	for val := range ch {
		fmt.Printf("Потребитель: получил %d\n", val)
	}

	// Поскольку цикл `for range ch` завершился, мы УЖЕ знаем, что горутина-продюсер
	// вызвала `close(ch)`. Из-за LIFO-порядка `defer`, мы также знаем, что `wg.Done()`
	// был вызван сразу после этого.
	// Поэтому вызов `wg.Wait()` здесь не будет ничего ждать и является избыточным.
	// Закрытый канал уже является достаточным сигналом о завершении.
	// wg.Wait()

	fmt.Println("Потребитель: канал закрыт. Программа завершена.")
}
