// Package main демонстрирует классический паттерн конкуренции "Производитель-Потребитель" (Producer-Consumer).
//
// 1. Производитель (producer): горутина, которая генерирует данные и отправляет их в канал.
// 2. Потребитель (consumer): горутина (в данном случае `main`), которая читает данные из канала и обрабатывает их.
// 3. Канал (channel): буфер, который безопасно передает данные от производителя к потребителю, разделяя их.
// 4. Контекст (context): используется для грациозной остановки производителя (например, по таймауту).
package main

import (
	"context"
	"fmt"
	"math/rand/v2" // Новый, потокобезопасный и автоматически сидируемый пакет из Go 1.22
	"sync"
	"time"
)

// producer генерирует случайные числа и отправляет их в канал до тех пор,
// пока не будет отменен контекст.
func producer(ctx context.Context, ch chan<- int, wg *sync.WaitGroup) {
	// `defer` выполняется в порядке LIFO (Last-In, First-Out).
	// 1. wg.Done() будет вызван последним, сообщая о полном завершении горутины.
	defer wg.Done()
	// 2. close(ch) будет вызван первым, сообщая потребителю, что данных больше не будет.
	defer close(ch)

	for {
		select {
		case <-ctx.Done():
			// Контекст был отменен, завершаем работу.
			fmt.Println("Производитель: контекст отменен, прекращаю генерацию.")
			return // defer'ы будут вызваны здесь.

		default:
			// Генерируем случайное число и отправляем его в канал.
			n := rand.IntN(100)
			ch <- n
			fmt.Printf("Производитель: отправил %d\n", n)

			// Небольшая задержка для имитации работы.
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	// Создаем контекст, который автоматически отменится через 3 секунды.
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	// defer cancel() гарантирует освобождение ресурсов, связанных с контекстом.
	defer cancel()

	// Канал для передачи данных от производителя к потребителю.
	ch := make(chan int)
	var wg sync.WaitGroup

	wg.Add(1)
	go producer(ctx, ch, &wg)

	// Потребитель (main горутина) читает данные из канала.
	fmt.Println("Потребитель: начал прием данных...")
	// Цикл `for range` над каналом — основной механизм синхронизации.
	// Он блокируется в ожидании данных и автоматически завершается, когда
	// производитель закрывает канал.
	for val := range ch {
		fmt.Printf("Потребитель: получил %d\n", val)
	}

	// Так как цикл `for range` завершился, мы знаем, что производитель
	// уже закрыл канал и завершил свою работу. Следовательно, его `wg.Done()`
	// также был вызван. Вызов `wg.Wait()` здесь является избыточным, но безвредным.
	// wg.Wait()

	fmt.Println("Потребитель: канал закрыт. Программа завершена.")
}
