// Package main демонстрирует базовый механизм синхронизации в Go — `sync.WaitGroup`.
// `WaitGroup` позволяет основной горутине дождаться завершения выполнения
// некоторого количества других горутин.
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	// 1. Создаем экземпляр WaitGroup.
	// Это счетчик, который будет отслеживать количество активных горутин.
	var wg sync.WaitGroup

	const numGoroutines = 20
	fmt.Printf("Запуск %d горутин...\n", numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		// 2. Увеличиваем счетчик WaitGroup на 1 перед запуском каждой горутины.
		// Это говорит `wg`, что нужно дождаться еще одной задачи.
		wg.Add(1)

		// Запускаем анонимную функцию в новой горутине.
		go func(workerID int) {
			// 3. Уменьшаем счетчик, когда горутина завершает свою работу.
			// `defer` гарантирует, что wg.Done() будет вызван в самом конце,
			// даже если внутри функции произойдет паника.
			defer wg.Done()

			// ВАЖНО: Мы передаем `i` как аргумент `workerID` в анонимную функцию.
			// Если бы мы использовали `i` напрямую из внешнего цикла, все горутины,
			// скорее всего, получили бы последнее значение `i` (т.е. 20),
			// так как они стартуют не мгновенно, а цикл for продолжает работать.
			// Это классическая ошибка при работе с горутинами в циклах.
			// Передача `i` как аргумента создает копию значения для каждой горутины.

			fmt.Printf("Воркер %d: квадрат числа = %d\n", workerID, workerID*workerID)
			// Имитация полезной работы
			time.Sleep(10 * time.Millisecond)

		}(i) // Передаем текущее значение `i` в горутину.
	}

	fmt.Println("Основная горутина: ожидание завершения всех воркеров...")
	// 4. `wg.Wait()` блокирует выполнение основной горутины до тех пор,
	// пока внутренний счетчик WaitGroup не станет равен 0.
	// Счетчик станет нулем, когда каждая горутина вызовет `wg.Done()`.
	wg.Wait()

	fmt.Println("Все воркеры завершили свою работу. Программа завершается.")

	// Закомментированная строка ниже — это анти-паттерн.
	// Использование `time.Sleep` для ожидания горутин ненадежно, так как
	// невозможно угадать, сколько времени займет их выполнение.
	// `sync.WaitGroup` — это правильный и детерминированный способ синхронизации.
	// time.Sleep(time.Second)
}
