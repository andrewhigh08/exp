// Package main демонстрирует паттерн конкуренции "Fan-In".
// Fan-In — это когда несколько горутин отправляют данные в один общий канал.
// Это позволяет главной горутине собирать результаты от множества "воркеров"
// по мере их готовности.
package main

import (
	"fmt"
	"time"
)

// City представляет задачу с определенной длительностью выполнения.
type City struct {
	name     string
	duration time.Duration
}

// DoRequest имитирует выполнение долгой задачи (например, сетевого запроса).
// После завершения "работы" (сна), метод отправляет имя города в общий канал.
func (c *City) DoRequest(resChan chan<- string) {
	// <-time.After(c.duration) — это простой способ заблокировать выполнение
	// на заданный промежуток времени.
	<-time.After(c.duration)

	// Отправляем результат в канал.
	resChan <- c.name
}

func main() {
	// Создаем несколько "задач" с разной длительностью.
	cities := []*City{
		{name: "MSK", duration: 4 * time.Second}, // Самая долгая задача
		{name: "SPB", duration: 1 * time.Second}, // Самая быстрая задача
		{name: "EKT", duration: 2 * time.Second},
	}

	// resChan — это общий канал, в который все горутины будут отправлять свои результаты.
	resChan := make(chan string)

	// Запускаем по одной горутине для каждой задачи.
	// Все три горутины стартуют практически одновременно.
	for _, city := range cities {
		go city.DoRequest(resChan)
	}

	// Основная горутина ожидает и печатает результаты.
	// Этот цикл выполнится `len(cities)` раз (3 раза).
	// На каждой итерации он блокируется на `<-resChan`, ожидая, пока ЛЮБАЯ
	// из горутин отправит результат.
	for range cities {
		// Как только результат приходит, он считывается и печатается.
		fmt.Println(<-resChan)
	}
}

/*
ОЖИДАЕМЫЙ РЕЗУЛЬТАТ ВЫВОДА:
SPB
EKT
MSK

ПОЧЕМУ ТАКОЙ ПОРЯДОК?
1. Все три горутины (`DoRequest`) запускаются почти одновременно.
2. Горутина "SPB" спит всего 1 секунду и первой отправляет свой результат в `resChan`.
   Главная горутина немедленно его получает и печатает "SPB".
3. Горутина "EKT" завершает свою 2-секундную задержку следующей, отправляет результат.
   Главная горутина получает и печатает "EKT".
4. Последней завершает работу горутина "MSK" (4 секунды), ее результат печатается последним.

Этот пример наглядно показывает, что при использовании каналов для сбора
результатов, они обрабатываются по мере их фактического поступления (готовности),
а не в том порядке, в котором были запущены задачи.
*/
