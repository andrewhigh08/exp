// Package main демонстрирует идиоматичный способ возврата результата или ошибки
// из горутины с использованием одного канала и специальной структуры.
// Имя каталога "cannel" скорее всего является опечаткой от "channel".
package main

import (
	"errors"
	"fmt"
	"time"
)

// Result — это структура, которая инкапсулирует результат выполнения операции.
// Она может содержать либо успешное значение (Value), либо ошибку (Err).
// Этот подход предпочтительнее, чем использование двух отдельных каналов
// для результата и ошибки, так как он проще в использовании и избегает состояний гонки.
type Result struct {
	Value string
	Err   error
}

// doWork запускает асинхронную операцию и возвращает канал только для чтения,
// по которому будет отправлен единственный экземпляр Result.
func doWork(shouldFail bool) <-chan Result {
	// Создаем небуферизированный канал, так как мы будем отправлять только одно значение.
	resultChan := make(chan Result)

	go func() {
		// Гарантируем, что канал будет закрыт при выходе из горутины.
		defer close(resultChan)

		fmt.Println("Воркер: начал работу...")
		time.Sleep(1 * time.Second) // Имитация долгой работы.

		if shouldFail {
			fmt.Println("Воркер: произошла ошибка.")
			// Отправляем результат с ошибкой.
			resultChan <- Result{Err: errors.New("не удалось выполнить задачу")}
		} else {
			fmt.Println("Воркер: работа успешно завершена.")
			// Отправляем успешный результат.
			resultChan <- Result{Value: "Задача выполнена"}
		}
	}()

	return resultChan
}

func main() {
	fmt.Println("--- Сценарий 1: Успешное выполнение ---")
	// Получаем канал с результатом для успешного сценария.
	resultChanSuccess := doWork(false)

	// Ожидаем результат из канала. Эта операция блокирует выполнение,
	// пока в канал не будет отправлено значение.
	resSuccess := <-resultChanSuccess

	// Проверяем поле Err в полученной структуре.
	if resSuccess.Err != nil {
		fmt.Printf("Получена ошибка: %v\n", resSuccess.Err)
	} else {
		fmt.Printf("Получен результат: '%s'\n", resSuccess.Value)
	}

	fmt.Println("\n--- Сценарий 2: Выполнение с ошибкой ---")
	// Получаем канал с результатом для сценария с ошибкой.
	resultChanFail := doWork(true)

	// Ожидаем результат.
	resFail := <-resultChanFail

	// Проверяем на наличие ошибки.
	if resFail.Err != nil {
		fmt.Printf("Получена ошибка: %v\n", resFail.Err)
	} else {
		fmt.Printf("Получен результат: '%s'\n", resFail.Value)
	}

	// ЗАМЕТКА ОБ ОШИБКЕ В ИСХОДНОМ КОДЕ:
	// В оригинальном примере использовался `select` с двумя каналами.
	// Проблема была в том, что горутина-производитель закрывала оба канала
	// одновременно с отправкой данных. Чтение из закрытого канала всегда
	// возможно и не блокируется. Это приводило к состоянию гонки в `select`,
	// где он мог случайным образом выбрать либо чтение успешного результата,
	// либо чтение нулевого значения из закрытого канала ошибок.
	// Паттерн с единой структурой Result решает эту проблему.
}
