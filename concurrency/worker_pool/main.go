package main

import (
	"fmt"
	"sync"
	"time"
)

// WP описывает интерфейс пула воркеров.
type WP interface {
	// Do добавляет задачу в очередь на выполнение.
	Do(task func())
	// Stop останавливает пул и ожидает завершения всех текущих задач.
	Stop()
}

// WorkerPool — реализация пула воркеров.
type WorkerPool struct {
	wg        sync.WaitGroup // WaitGroup для ожидания завершения всех горутин-воркеров.
	tasks     chan func()    // Канал для передачи задач воркерам.
	closeOnce sync.Once      // Гарантирует, что канал будет закрыт только один раз.
}

// NewWp создает новый пул воркеров с заданным количеством горутин.
func NewWp(workers int) *WorkerPool {
	wp := &WorkerPool{
		tasks: make(chan func()), // Небуферизированный канал (можно сделать буферизированным).
	}

	// Запускаем заданное количество воркеров.
	for i := 0; i < workers; i++ {
		wp.wg.Add(1) // Увеличиваем счетчик WaitGroup для каждого воркера.
		go wp.worker(i)
	}

	return wp
}

// worker — это функция, которая выполняется в каждой горутине-воркере.
func (wp *WorkerPool) worker(id int) {
	defer wp.wg.Done() // Уменьшаем счетчик WaitGroup при завершении воркера.

	// Читаем задачи из канала tasks, пока он не будет закрыт.
	for task := range wp.tasks {
		fmt.Printf("Воркер %d: начал выполнение задачи\n", id)
		task() // Выполняем задачу.
		fmt.Printf("Воркер %d: закончил выполнение задачи\n", id)
	}
	fmt.Printf("Воркер %d: остановлен\n", id)
}

// Do отправляет задачу в пул.
// Примечание: Если вызвать Do после Stop, произойдет паника (отправка в закрытый канал).
func (wp *WorkerPool) Do(task func()) {
	wp.tasks <- task
}

// Stop корректно останавливает пул воркеров.
func (wp *WorkerPool) Stop() {
	// Используем sync.Once, чтобы закрыть канал только один раз,
	// даже если Stop будет вызван несколько раз.
	wp.closeOnce.Do(func() {
		close(wp.tasks) // Закрываем канал, что служит сигналом для воркеров завершить цикл range.
		wp.wg.Wait()    // Ожидаем, пока все воркеры закончат свои текущие задачи и выйдут.
	})
}

func main() {
	// Создаем пул из 3 воркеров.
	wp := NewWp(3)

	// Отправляем первую задачу.
	wp.Do(func() {
		fmt.Println("Задача 1 выполняется")
		time.Sleep(500 * time.Millisecond)
	})

	// Запускаем горутину, которая отправит еще одну задачу.
	go func() {
		wp.Do(func() {
			fmt.Println("Задача 2 (из горутины) выполняется")
			time.Sleep(500 * time.Millisecond)
		})
	}()

	// Даем немного времени, чтобы задачи успели попасть в канал перед остановкой.
	// В реальном коде управление жизненным циклом может быть сложнее.
	time.Sleep(100 * time.Millisecond)

	fmt.Println("Остановка пула...")
	wp.Stop()
	fmt.Println("Пул остановлен, программа завершена.")
}
