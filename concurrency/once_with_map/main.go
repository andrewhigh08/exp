// Package main демонстрирует распространенную ошибку при работе с каналами и мьютексами,
// которая приводит к взаимной блокировке (deadlock), и показывает правильный способ ее решения.
//
// Задача: конкурентно найти уникальные элементы в срезе и собрать их.
package main

import (
	"fmt"
	"math/rand"
	"sync"
)

func main() {
	const capacity = 1000

	// `storage` будет использоваться как set для проверки уникальности.
	storage := make(map[int]struct{})
	// Используем обычный Mutex, так как RWMutex здесь избыточен (нет разделения на читателей/писателей).
	var mu sync.Mutex
	var wg sync.WaitGroup

	// `sourceData` содержит исходные данные с дубликатами.
	sourceData := make([]int, 0, capacity)
	for i := 0; i < capacity; i++ {
		sourceData = append(sourceData, rand.Intn(100)) // Генерируем числа от 0 до 99.
	}

	// Канал для сбора найденных уникальных ID.
	uniqueIDsChan := make(chan int, capacity)

	wg.Add(capacity)
	fmt.Printf("Запуск %d горутин для поиска уникальных чисел...\n", capacity)

	for _, item := range sourceData {
		go func(item int) {
			defer wg.Done()

			isUnique := false

			// --- Начало критической секции ---
			mu.Lock()
			// Проверяем, видели ли мы уже этот элемент.
			if _, ok := storage[item]; !ok {
				// Если нет, помечаем, что он уникален, и добавляем в set.
				storage[item] = struct{}{}
				isUnique = true
			}
			mu.Unlock()
			// --- Конец критической секции ---

			// ОШИБКА В ИСХОДНОМ КОДЕ (DEADLOCK):
			// Отправка в канал `uniqueIDsChan <- item` находилась ВНУТРИ блокировки мьютекса.
			// Если бы все горутины попытались отправить данные в переполненный канал,
			// они бы заблокировались, не отпуская мьютекс. В то же время, главная
			// горутина ждала бы их завершения на `wg.Wait()` и не могла бы читать
			// из канала. Это классический deadlock.

			// ПРАВИЛЬНОЕ РЕШЕНИЕ:
			// Сначала полностью завершить работу с разделяемой памятью (картой `storage`)
			// и отпустить мьютекс, и только ПОСЛЕ этого выполнять потенциально
			// блокирующую операцию отправки в канал.
			if isUnique {
				uniqueIDsChan <- item
			}
		}(item)
	}

	// Ожидаем завершения всех горутин-обработчиков.
	wg.Wait()
	// После того как все горутины завершились, мы можем безопасно закрыть канал.
	// Это сигнал для цикла `for range` ниже, что данных больше не будет.
	close(uniqueIDsChan)

	// --- Сбор и вывод результатов ---
	// Собираем все уникальные значения из канала в срез.
	uniqueSlice := make([]int, 0, len(uniqueIDsChan))
	for val := range uniqueIDsChan {
		uniqueSlice = append(uniqueSlice, val)
	}

	// ОШИБКА В ИСХОДНОМ КОДЕ:
	// `len(uniqueIDs)` после цикла `for range` всегда будет 0, так как канал уже пуст.
	// Нужно измерять длину среза, в который мы собрали результаты.

	fmt.Printf("\nНайдено %d уникальных чисел:\n", len(uniqueSlice))
	fmt.Println(uniqueSlice)
}
