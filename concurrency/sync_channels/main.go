// Package main демонстрирует базовый паттерн конкуренции в Go — "генератор".
// Генератор — это функция, которая запускает горутину для выполнения какой-либо работы
// и возвращает канал, через который можно получать результаты этой работы.
package main

import (
	"fmt"
)

// spawnMessages запускает горутину, которая генерирует n сообщений и отправляет их в канал.
//
// Возвращаемый тип `<-chan string` — это канал "только для чтения".
// Это идиоматичный способ в Go показать, что функция-потребитель (в данном случае main)
// должна только читать из канала, а не писать в него или закрывать его.
// Это делает API более безопасным и предсказуемым.
func spawnMessages(n int) <-chan string {
	// Создаем буферизированный канал. Буфер размером 1 здесь не играет большой роли,
	// но может помочь в ситуациях, когда потребитель немного отстает от производителя.
	ch := make(chan string, 1)

	// Запускаем анонимную функцию в отдельной горутине.
	// Это позволяет `spawnMessages` немедленно вернуть канал, не дожидаясь
	// завершения генерации всех сообщений.
	go func() {
		// Важно: закрытие канала должно происходить в той же горутине,
		// которая в него пишет (производитель).
		defer close(ch)

		for i := 0; i < n; i++ {
			ch <- fmt.Sprintf("сообщение %d", i+1)
		}
		// После завершения цикла `defer close(ch)` будет вызван.
		// Закрытие канала — это сигнал для потребителя о том, что данных больше не будет.
	}()

	return ch
}

func main() {
	n := 10

	// Использование `for ... range` для итерации по каналу — самый идиоматичный
	// способ получать данные. Цикл автоматически завершится, когда канал
	// будет закрыт в горутине-производителе.
	fmt.Printf("Ожидание %d сообщений от генератора...\n", n)
	for msg := range spawnMessages(n) {
		fmt.Println("Получено:", msg)
	}
	fmt.Println("Все сообщения получены. Канал был закрыт, программа завершается.")
}
