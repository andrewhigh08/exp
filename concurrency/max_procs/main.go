// Package main демонстрирует поведение планировщика Go и недетерминизм
// при выполнении горутин, особенно при ограничении до одного потока ОС.
package main

import (
	"fmt"
	"runtime"
	"sync"
)

// runWorkers запускает 5 горутин, каждая из которых печатает свой ID.
func runWorkers(description string) {
	fmt.Printf("\n--- %s ---\n", description)

	var wg sync.WaitGroup
	wg.Add(5)

	for i := 0; i < 5; i++ {
		// Передаем `i` как аргумент, чтобы каждая горутина получила свой уникальный ID.
		go func(workerID int) {
			defer wg.Done()
			// runtime.Gosched() можно было бы использовать здесь, чтобы "подсказать"
			// планировщику, что можно переключиться на другую горутину.
			// Но даже без этого, вызов fmt.Println (операция I/O) является
			// точкой прерывания, где планировщик может сменить контекст.
			fmt.Printf("%d ", workerID)
		}(i)
	}

	wg.Wait()
	fmt.Println()
}

func main() {
	// --- Сценарий 1: Ограничение до одного потока ОС ---
	// runtime.GOMAXPROCS(1) заставляет планировщик Go использовать только один
	// поток операционной системы для выполнения всех горутин. Это означает,
	// что в каждый момент времени может исполняться только одна горутина.
	// Планировщик будет "переключать" горутины на этом единственном потоке.
	//
	// Ожидаемый результат: Порядок вывода чисел (0 1 2 3 4) НЕ ГАРАНТИРОВАН.
	// Пример вывода в комментариях (4 0 1 2 3) показывает, что планировщик
	// может запустить последнюю горутину (с ID 4) раньше, чем другие,
	// которые уже были готовы к выполнению. Это иллюстрирует недетерминизм.
	oldMaxProcs := runtime.GOMAXPROCS(1)
	runWorkers("Выполнение на одном потоке (GOMAXPROCS=1)")

	// --- Сценарий 2: Использование всех доступных потоков ---
	// Возвращаем GOMAXPROCS к значению по умолчанию (обычно равно количеству ядер CPU).
	runtime.GOMAXPROCS(oldMaxProcs)
	runWorkers(fmt.Sprintf("Выполнение на %d потоках (по умолчанию)", runtime.NumCPU()))
	// В этом случае горутины могут выполняться по-настоящему параллельно на разных ядрах,
	// но порядок вывода все равно не гарантирован и зависит от сложного взаимодействия
	// планировщика и операционной системы.

	fmt.Println("\nВывод: Порядок выполнения горутин недетерминирован и не должен зависеть от внешних факторов без явной синхронизации (каналы, мьютексы и т.д.).")
}

/*
Пример возможного вывода при GOMAXPROCS(1):
4 0 1 2 3

Это происходит потому, что цикл for может успеть запуститься и поставить все 5 горутин
в очередь на выполнение до того, как первая из них реально начнет печатать.
Планировщик может выбрать последнюю поставленную в очередь горутину для выполнения первой.
*/
