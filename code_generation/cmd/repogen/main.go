// Package main — это утилита для автоматической генерации кода (кодогенератор).
//
// Данный генератор анализирует исходный Go-файл, находит в нем структуры,
// помеченные специальным комментарием `//repogen:entity`, и создает для них
// базовую реализацию CRUD-репозитория, используя GORM.
//
// ИСПОЛЬЗОВАНИЕ:
// Этот инструмент предназначен для вызова через `go generate`.
// В файле, где определены ваши структуры данных (модели), добавьте директиву:
//
// //go:generate go run full/path/to/repogen/main.go
//
// После этого, запуск `go generate ./...` в вашем проекте автоматически создаст
// файлы `*_gen.go` с кодом репозиториев.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"reflect"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/go/ast/inspector"
)

// repositoryTemplate — это шаблон text/template, на основе которого генерируется код репозитория.
// template.Must используется для того, чтобы паниковать при запуске, если шаблон некорректен.
var repositoryTemplate = template.Must(template.New("").Parse(`
// Code generated by repogen. DO NOT EDIT.
package main

import (
    "github.com/jinzhu/gorm"
)

type {{ .EntityName }}Repository struct {
    db *gorm.DB
}

func New{{ .EntityName }}Repository(db *gorm.DB) {{ .EntityName }}Repository {
    return {{ .EntityName }}Repository{ db: db}
}

func (r {{ .EntityName }}Repository) Get({{ .PrimaryName }} {{ .PrimaryType}}) (*{{ .EntityName }}, error) {
    entity := new({{ .EntityName }})
    err := r.db.Limit(1).Where("{{ .PrimarySQLName }} = ?", {{ .PrimaryName }}).Find(entity).Error()
    return entity, err
}


func (r {{ .EntityName }}Repository) Create(entity *{{ .EntityName }}) error {
    return r.db.Create(entity).Error
}

func (r {{ .EntityName }}Repository) Update(entity *{{ .EntityName }}) error {
    return r.db.Model(entity).Update(entity).Error
}

func (r {{ .EntityName }}Repository) Delete(entity *{{ .EntityName }}) error {
    return r.db.Delete(entity).Error
}
`))

// repositoryGenerator хранит информацию, необходимую для генерации одного репозитория.
type repositoryGenerator struct {
	typeSpec   *ast.TypeSpec
	structType *ast.StructType
}

// expr2string преобразует узел AST `ast.Expr` в его строковое представление.
// Это нужно, чтобы получить имя типа поля (например, "int" или "string").
func expr2string(expr ast.Expr) string {
	var buf bytes.Buffer
	err := printer.Fprint(&buf, token.NewFileSet(), expr)
	if err != nil {
		log.Fatalf("ошибка конвертации выражения в строку: %v", err)
	}
	return buf.String()
}

// primaryField находит поле структуры, помеченное как первичный ключ.
// Поиск ведется по тегу `gorm:"primary_key"`.
func (r repositoryGenerator) primaryField() (*ast.Field, error) {
	for _, field := range r.structType.Fields.List {
		if field.Tag == nil {
			continue
		}
		// Используем reflect.StructTag для удобного парсинга тегов.
		tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
		if strings.Contains(tag.Get("gorm"), "primary_key") {
			return field, nil
		}
	}
	return nil, fmt.Errorf("не найден первичный ключ (gorm:\"primary_key\") в структуре %s", r.typeSpec.Name.Name)
}

// getColumnName извлекает имя колонки из тега `gorm:"column:..."`.
// Если тег отсутствует, используется имя поля структуры в snake_case.
func getColumnName(field *ast.Field) string {
	if field.Tag == nil {
		return toSnakeCase(field.Names[0].Name)
	}
	tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
	gormTag := tag.Get("gorm")
	for _, part := range strings.Split(gormTag, ";") {
		if strings.HasPrefix(part, "column:") {
			return strings.TrimPrefix(part, "column:")
		}
	}
	return toSnakeCase(field.Names[0].Name)
}

// Generate выполняет основную логику генерации кода для одного репозитория.
func (r repositoryGenerator) Generate(outFile *ast.File) error {
	// Находим поле, которое является первичным ключом.
	primary, err := r.primaryField()
	if err != nil {
		return err
	}

	// Готовим параметры для передачи в шаблон.
	params := struct {
		EntityName     string
		PrimaryName    string
		PrimarySQLName string
		PrimaryType    string
	}{
		EntityName:     r.typeSpec.Name.Name,
		PrimaryName:    primary.Names[0].Name,
		PrimarySQLName: getColumnName(primary), // Получаем имя колонки из тега.
		PrimaryType:    expr2string(primary.Type),
	}

	// 1. Выполняем шаблон с параметрами и записываем результат в буфер.
	var buf bytes.Buffer
	err = repositoryTemplate.Execute(&buf, params)
	if err != nil {
		return fmt.Errorf("ошибка выполнения шаблона: %v", err)
	}

	// 2. Парсим сгенерированный код обратно в AST.
	templateAst, err := parser.ParseFile(
		token.NewFileSet(),
		"", // Имя файла не нужно, т.к. источник - буфер.
		buf.Bytes(),
		parser.ParseComments,
	)
	if err != nil {
		return fmt.Errorf("ошибка парсинга сгенерированного шаблона: %v", err)
	}

	// 3. Добавляем все сгенерированные объявления (imports, types, funcs) в выходной файл.
	for _, decl := range templateAst.Decls {
		outFile.Decls = append(outFile.Decls, decl)
	}
	return nil
}

func main() {
	// `go generate` устанавливает несколько переменных окружения. GOFILE - одна из них.
	path := os.Getenv("GOFILE")
	if path == "" {
		log.Fatal("Переменная окружения GOFILE должна быть установлена. Запустите через `go generate`.")
	}

	// 1. Парсим исходный файл в AST.
	fset := token.NewFileSet()
	astInFile, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("ошибка парсинга файла %s: %v", path, err)
	}

	// 2. Ищем задания для генерации.
	// Используем inspector для удобного обхода AST.
	i := inspector.New([]*ast.File{astInFile})
	filter := []ast.Node{
		(*ast.GenDecl)(nil), // Нас интересуют только общие объявления (type, var, const).
	}

	var genTasks []repositoryGenerator
	i.Nodes(filter, func(node ast.Node, push bool) (proceed bool) {
		genDecl := node.(*ast.GenDecl)

		// Пропускаем объявления без комментариев.
		if genDecl.Doc == nil {
			return false
		}
		// Проверяем, что это объявление типа (`type ...`)
		if len(genDecl.Specs) == 0 {
			return false
		}
		typeSpec, ok := genDecl.Specs[0].(*ast.TypeSpec)
		if !ok {
			return false
		}
		// И что это структура (`struct { ... }`)
		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return false
		}

		// Ищем "магический" комментарий.
		for _, comment := range genDecl.Doc.List {
			if comment.Text == "//repogen:entity" {
				// Нашли задание! Добавляем в список.
				genTasks = append(genTasks, repositoryGenerator{
					typeSpec:   typeSpec,
					structType: structType,
				})
				// Мы нашли то, что искали в этом GenDecl, дальше можно не идти.
				return false
			}
		}
		return true
	})

	if len(genTasks) == 0 {
		log.Println("Не найдено структур с комментарием //repogen:entity. Генерация не требуется.")
		return
	}

	// 3. Генерируем код для каждого найденного задания.
	astOutFile := &ast.File{
		Name: astInFile.Name, // Имя пакета должно совпадать с исходным.
	}

	for _, task := range genTasks {
		err = task.Generate(astOutFile)
		if err != nil {
			log.Fatalf("ошибка генерации для %s: %v", task.typeSpec.Name.Name, err)
		}
	}

	// 4. Сохраняем результат в файл.
	outFileName := strings.TrimSuffix(path, ".go") + "_gen.go"
	outFile, err := os.Create(outFileName)
	if err != nil {
		log.Fatalf("ошибка создания файла %s: %v", outFileName, err)
	}
	defer outFile.Close()

	// Используем printer для форматирования и записи AST в файл.
	// Это гарантирует, что сгенерированный код будет отформатирован согласно `gofmt`.
	err = printer.Fprint(outFile, token.NewFileSet(), astOutFile)
	if err != nil {
		log.Fatalf("ошибка записи в файл %s: %v", outFileName, err)
	}

	log.Printf("Успешно сгенерирован файл: %s", outFileName)
}

// toSnakeCase преобразует строку из CamelCase в snake_case.
// Например, "MyFieldName" -> "my_field_name".
func toSnakeCase(str string) string {
	var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	var matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")

	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}
