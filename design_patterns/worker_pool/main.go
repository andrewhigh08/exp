package main

import (
	"fmt"
	"sync"
	"time"
)

// Job — это данные, необходимые для выполнения работы.
type Job struct {
	ID int
}

// Result — это результат выполненной работы.
type Result struct {
	JobID  int
	Output int
}

// worker — функция-обработчик.
// Она запускается в виде горутины и "слушает" канал jobs.
func worker(id int, jobs <-chan Job, results chan<- Result) {
	// range по каналу работает до тех пор, пока канал не будет закрыт (close(jobs))
	// и буфер канала не опустеет.
	for job := range jobs {
		fmt.Printf("[Воркер %d] Начал задачу %d\n", id, job.ID)

		// Симуляция полезной нагрузки / обращения к БД / вычислений
		time.Sleep(time.Second)

		fmt.Printf("[Воркер %d] Закончил задачу %d\n", id, job.ID)

		// Отправляем результат в канал сбора данных.
		results <- Result{
			JobID:  job.ID,
			Output: job.ID * 2,
		}
	}
	// Этот код выполнится только после того, как jobs будет закрыт
	fmt.Printf("[Воркер %d] Остановка (канал jobs закрыт)\n", id)
}

func main() {
	const (
		numJobs    = 10 // Общее количество задач
		numWorkers = 3  // Количество параллельных воркеров
	)

	// Канал задач (Buffered Channel).
	// Буфер позволяет Продюсеру не блокироваться мгновенно, если воркеры заняты.
	jobs := make(chan Job, numJobs)

	// Канал результатов.
	results := make(chan Result, numJobs)

	// WaitGroup нужна для синхронизации закрытия канала results.
	// Мы должны знать, когда ВСЕ воркеры закончат писать в results, чтобы безопасно закрыть его.
	var wg sync.WaitGroup

	// --- ЭТАП 1: Запуск Воркеров (Consumers) ---
	// Запускаем фиксированное количество горутин. Они сразу начнут ждать задач из канала jobs.
	for w := 1; w <= numWorkers; w++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done() // Сигнализируем о завершении воркера при выходе из функции
			worker(id, jobs, results)
		}(w)
	}

	// --- ЭТАП 2: Генерация задач (Producer) ---
	// Запускаем в отдельной горутине, чтобы не блокировать main.
	// Если jobs переполнится (при большом кол-ве задач и медленных воркерах),
	// блокировка произойдет здесь, в этой горутине, а не в основном потоке.
	go func() {
		for j := 1; j <= numJobs; j++ {
			jobs <- Job{ID: j}
		}
		// ВАЖНО: Закрываем канал задач.
		// Это сигнал всем воркерам: "Задач больше не будет, доделывайте текущие и выходите".
		close(jobs)
	}()

	// --- ЭТАП 3: Оркестрация закрытия (Closer) ---
	// Нам нужно закрыть канал results, чтобы цикл range в main (Этап 4) завершился.
	// Но закрывать можно только тогда, когда ВСЕ воркеры отработали (wg.Done).
	// Мы делаем это в отдельной горутине, потому что wg.Wait() — это блокирующая операция.
	go func() {
		wg.Wait()      // Ждем завершения всех воркеров (все 3 горутины worker вышли)
		close(results) // Теперь безопасно закрываем канал результатов
		fmt.Println("--- Все воркеры завершили работу, канал results закрыт ---")
	}()

	// --- ЭТАП 4: Сбор результатов (Main Consumer) ---
	// Читаем из results, пока канал открыт.
	// Как только "Closer" закроет канал (после завершения всех воркеров), цикл прервется.
	// Это гарантирует, что мы обработаем ровно столько ответов, сколько было отправлено,
	// и программа корректно завершится.
	for result := range results {
		fmt.Printf(">> Главный поток: Получен результат задачи %d: %d\n", result.JobID, result.Output)
	}

	fmt.Println("Все задачи обработаны. Выход.")
}
