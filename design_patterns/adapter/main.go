// Package main демонстрирует реализацию структурного паттерна проектирования "Адаптер".
//
// Паттерн "Адаптер" (Adapter) позволяет объектам с несовместимыми интерфейсами работать вместе.
// Он действует как "переводчик" между двумя объектами.
//
// Когда использовать:
// 1. Когда вы хотите использовать существующий класс, но его интерфейс не соответствует вашим требованиям.
// 2. Когда нужно создать единый интерфейс для нескольких разнородных классов.
//
// Компоненты паттерна:
// - Целевой интерфейс (Target): интерфейс, который ожидает клиентский код. (В нашем примере - `Logger`)
// - Адаптируемый класс (Adaptee): существующий класс с несовместимым интерфейсом. (В нашем примере - `ThirdPartyLogger`)
// - Адаптер (Adapter): класс-обертка, который реализует целевой интерфейс и использует экземпляр адаптируемого класса. (В нашем примере - `LoggerAdapter`)
package main

import "fmt"

// Logger — это целевой интерфейс (Target).
// Наш клиентский код хочет работать с любым объектом, который реализует этот интерфейс.
type Logger interface {
	Log(message string)
}

// --- Адаптируемый компонент ---

// ThirdPartyLogger — это адаптируемый класс (Adaptee).
// Представим, что это логгер из сторонней библиотеки, который мы не можем изменить.
// Его метод `PrintLog` имеет другую сигнатуру, чем мы ожидаем в `Logger`.
type ThirdPartyLogger struct{}

// PrintLog — метод с несовместимым именем.
func (t *ThirdPartyLogger) PrintLog(msg string) {
	fmt.Println("ThirdPartyLog:", msg)
}

// --- Адаптер ---

// LoggerAdapter — это класс-Адаптер.
// Он "оборачивает" ThirdPartyLogger и реализует наш целевой интерфейс `Logger`.
type LoggerAdapter struct {
	ThirdPartyLogger *ThirdPartyLogger
}

// Log — это реализация метода из интерфейса `Logger`.
// Внутри этого метода адаптер делегирует вызов адаптируемому объекту,
// преобразуя его в нужный формат.
func (a *LoggerAdapter) Log(message string) {
	// Преобразуем вызов Log(message) в вызов a.ThirdPartyLogger.PrintLog(message).
	a.ThirdPartyLogger.PrintLog(message)
}

// clientCode — это пример клиентского кода, который зависит только от интерфейса Logger.
// Ему неважно, какая конкретная реализация логгера используется.
func clientCode(logger Logger) {
	logger.Log("Сообщение от клиентского кода")
}

func main() {
	fmt.Println("Демонстрация паттерна Адаптер:")

	// Создаём экземпляр стороннего логгера (Adaptee).
	thirdPartyLogger := &ThirdPartyLogger{}
	fmt.Println("Создан сторонний логгер. Он имеет метод `PrintLog`.")

	// Создаём адаптер, "оборачивая" в него сторонний логгер.
	// Адаптер реализует наш интерфейс `Logger`.
	adapter := &LoggerAdapter{ThirdPartyLogger: thirdPartyLogger}
	fmt.Println("Создан адаптер, который реализует интерфейс `Logger`.")

	// Теперь мы можем передать наш адаптер в клиентский код,
	// который ожидает любой `Logger`.
	fmt.Println("Передаем адаптер в клиентский код...")
	clientCode(adapter)
}
