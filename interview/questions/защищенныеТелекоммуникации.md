```go
package main

import (
	"encoding/json"
	"fmt"
	"runtime"
	"time"
)

func main() {
	//testSlices1()
	//testSlices2()
	//testSlices3()
	//testSlices4()
	//testData1()
	//testData2()
	//testGoroutines1()
	//testGoroutines2()
	//testGoroutines3()
	//testGoroutines4()
	testGoroutines5()
}

func testSlices1() {
	a := []string{"a", "b", "c"} // len=3, cap=3
	b := a[1:2]                  // "b" len=1, cap 2
	b[0] = "q"                   // "q"
	fmt.Printf("%s\n", a)        // [a q c]
}

func testSlices2() {
	a := []byte{'a', 'b', 'c'} // len=3, cap=3
	b := append(a[1:2], 'd')   // b {'b', 'd'} // "b" len=2, cap 2
	b[0] = 'z'                 // {'z', 'd'}
	fmt.Printf("%s\n", a)      // azd
}

func testSlices3() {
	a := []byte{'a', 'b', 'c'}    // len=3, cap=3
	b := append(a[1:2], 'd', 'x') // 'b', 'd', 'x' len = 3, cap = 8
	fmt.Println(len(b), cap(b))   // 3 8
	b[0] = 'z'                    // "z", "d", "x"
	fmt.Printf("%s\n", a)         //'a', 'b', 'c'
}

func testSlices4() {
	a := []byte{'a', 'b', 'c'}
	b := string(a)
	a[0] = 'z'            //'z', 'b', 'c'
	fmt.Printf("%s\n", b) //"abc"
}

type MyData struct {
	One int    `json:"one"`
	two string `json:"two"`
}

func testData1() {
	in := MyData{1, "two"}
	fmt.Printf("%#v\n", in) // main.MyData{One:1, two:"two"}
	encoded, _ := json.Marshal(in)
	fmt.Println(string(encoded)) // {"one":1}
	var out MyData
	json.Unmarshal(encoded, &out)
	fmt.Printf("%#v\n", out) // main.MyData{One:1, two:""}

}

func testData2() {
	a := []int{1, 2, 3, 4}
	result := make([]*int, len(a)) // len 4
	for i, v := range a {
		result[i] = &v
	}
	for _, u := range result {
		fmt.Printf("%d ", *u) // 1 2 3 4 в версии до 1.22 4 4 4 4
	}
}

func testGoroutines1() {
	//var ch chan int
	ch := make(chan int) // если инициализировать канал, то выведет result: 6
	for i := 0; i < 3; i++ {
		go func(idx int) {
			ch <- (idx + 1) * 2
		}(i)
	}
	fmt.Println("result:", <-ch)

	time.Sleep(2 * time.Second)
} // fatal error: all goroutines are asleep - deadlock!

func testGoroutines2() {
	ch := make(chan string)
	go func() {
		for m := range ch {
			fmt.Println("processed:", m)
		}
	}()
	ch <- "cmd.1"
	ch <- "cmd.2"
	// close (ch)
	/*Закрытие канала после того, как все данные были отправлены, является хорошей практикой, которая позволяет
	горутине завершить работу корректно. В противном случае, горутина будет ожидать новые данные из канала бесконечно,
	что может привести к непредсказуемому поведению программы.*/
}

func testGoroutines3() {
	var num int

	for i := 0; i < 10000; i++ {
		go func() { // здесь нужно убрать go что бы вывелось 9999, иначе будет выводиться число до 9999
			num = i
		}()
	}
	fmt.Printf("NUM is %d", num)
}

func testGoroutines4() {
	dataMap := make(map[string]int)
	for i := 0; i < 10000; i++ {
		go func(d map[string]int, num int) {
			d[fmt.Sprintf("%d", num)] = num
		}(dataMap, i)
	}
	time.Sleep(5 * time.Second)
	fmt.Println(len(dataMap))
} // fatal error: concurrent map writes

func testGoroutines5() {
	runtime.GOMAXPROCS(1)

	x := 0
	go func(p *int) {
		for i := 1; i <= 20000000000; i++ {
			*p = i
		}
	}(&x)

	time.Sleep(100 * time.Millisecond)

	fmt.Printf("x = %d.\n", x)
}

/*	•	Ограничение на один поток: Поскольку GOMAXPROCS(1) ограничивает программу одним потоком, выполнение
основной горутины (которая выполняет time.Sleep и затем выводит значение x) и параллельно запущенной горутины,
которая обновляет x, будет чередоваться в этом единственном потоке. Это значит, что обновления значения x будут
происходить в промежутках между выполнением основной горутины.
	•	Неопределенность результата: Значение x, которое будет выведено, зависит от того, сколько раз горутина
успеет обновить x до того, как основная горутина захватит поток и выполнит fmt.Printf. Время задержки в
100 миллисекунд достаточно долгое, чтобы горутина могла выполнить много итераций цикла, но точное значение x
будет зависеть от того, как операционная система распределит время выполнения между горутинами. Поэтому результат
x будет неопределенным, но достаточно большим числом, и будет отличаться при каждом запуске программы.*/

```
