
1. Что такое `slice` и в чём различие с `array`?
2. Что такое `len` и `cap` у `slice`?
3. Чему будет равна каждая из объявленных констант и почему?
```go
package main

import "fmt"

const (
	A    = iota       	// 0
	_                 	// 1
	B, C = iota, iota 	// 2, 2
	D    = 0
	E    = iota 		// 4
)

func main_() {
	fmt.Println(A, B, C, D, E) 	//0 2 2 0 4
}
```

4. Что выведет программа и почему?
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for _, v := range []string{"a", "b", "c"} {
		wg.Add(1)
		go func(v string) {
			fmt.Println(v)
			wg.Done()
		}(v)
	}

	wg.Wait()
}

func main_() {
	var wg sync.WaitGroup
	ch := make(chan string)

	go func() {
		for v := range ch {
			fmt.Println(v)
			wg.Done()
		}
	}()

	for _, v := range []string{"a", "b", "c"} {
		wg.Add(1)
		ch <- v
	}

	wg.Wait()
	close(ch)
}

```

5. Что выведет программа и почему?
```go
package main

import "fmt"

func main() {
	a := [3]string{"a", "b", "c"} // {"e", "b", "c"}
	b := a[:]                     //0:len(a) slice len 3 cap 3
	b = append(b, "d")            // b = [a b c d] len 4 cap 6
	a[0] = "e"
	fmt.Println(b)                // a b c d

}
```

6. Что выведет программа и почему?
```go
package main

import "fmt"

func add(s []string, what string) {
	s = append(s, what) // ["a", "b"]
	fmt.Println(s)      // ["a", "b", "d"]
}

func main() {
	a := []string{"a", "b", "c"}[:2] // a = ["a", "b"]
	add(a, "d")
	fmt.Println(a)                   // "a", "b"
}
```

7. Что выведет программа и почему?
```go
package main

import (
	"errors"
	"fmt"
)

func print(a any) {
	fmt.Println(a)
}

func main() {
	err := errors.New("no error")
	print(err) // no error

	defer func() { print(err) }() // error
	//defer print(err) // no error

	err = errors.New("error")
}
```

8. В чем отличие `go routine` от `thread` ОС или это одно и то же?

9. Что выведет программа и почему?
```go
package main

import "fmt"

func main() {
	a := make(chan int)
	a <- 10
	fmt.Println(<-a) // fatal error: all goroutines are asleep - deadlock!
}
```

10. Что в go с ООП?

11. Что выведет программа и почему?
```go
func main() {
	var a any // nil
	//fmt.Println(a)        // nil
	var err *fs.PathError // err == nil
	//fmt.Println(&err)     // 0x14000116020

	a = err                 // a == nil
	fmt.Println(a == err)   // true
	fmt.Println(err == nil) // true
	fmt.Println(a == nil)   // false
	/*Ваш пример демонстрирует интересное поведение в Go, связанное с типом interface{} (в данном случае используется как any, который является алиасом для interface{} в более новых версиях Go) и nil.

	Когда вы присваиваете переменной интерфейсного типа значение nil, результат зависит от контекста:

	var a any объявляет переменную a с типом any (или interface{}), которая изначально имеет значение nil. Однако, это nil интерфейсного типа, что означает, что и тип, и значение внутри интерфейса равны nil.

	var err *fs.PathError объявляет указатель на fs.PathError, который изначально nil. Это конкретный тип *fs.PathError, а не интерфейс.

	Когда вы присваиваете err переменной a (a = err), вы фактически присваиваете интерфейсу значение, которое является nil указателем типа *fs.PathError. В этот момент интерфейс a содержит две части информации: тип (*fs.PathError) и значение (которое nil). Это отличается от "абсолютного" nil, который не содержит никакой информации о типе.

	Поэтому, когда вы сравниваете a == err, результат true, потому что a хранит nil значение типа *fs.PathError, который совпадает с err.

	Сравнение err == nil также true, потому что err действительно содержит nil и не был инициализирован каким-либо значением.

	Однако, a == nil возвращает false, поскольку a не является "чистым" nil; оно содержит тип (*fs.PathError), даже если его значение nil. Для интерфейса быть равным nil, и тип, и значение внутри интерфейса должны быть nil.

	Это одна из тонкостей Go, которая может сбивать с толку: интерфейс, содержащий nil значение некоторого типа, не равен nil как абстрактному понятию. Это важно учитывать при работе с интерфейсами и nil значениями.*/
}
```

12. Если приложение очень часто (сотни раз в секунду) выделяет буфера и так же часто их освобождает - есть ди способ облегчить работу "сборщику мусора"? Если есть - то какой?

13. Что выведет программа и почему?
```go
package main

import (
	"fmt"
	"maps"
)

func makeMapCopy(src map[int]int) (dst map[int]int) {
	dst = src //?
	return
}

func main() {
	src := map[int]int{
		0: 1,
		1: 2,// 1: 20
		2: 3,
	}
	dst := makeMapCopy(src)

	src[1] = 20

	fmt.Println(dst[1]) //1: 20
}
```

14. Что такое `gRPC`?

15. Как добиться мултиплексирования в `gRPC`, чтобы следующий `rpc` не ждал завершения предыдущего?

Мултиплексирование в gRPC позволяет одновременно обрабатывать множество запросов на одном соединении. Это достигается благодаря использованию HTTP/2, который является основой gRPC и поддерживает мултиплексирование "из коробки". В HTTP/2 одно TCP соединение может переносить множество потоков данных (streams), позволяя таким образом отправлять параллельные запросы и получать ответы в любом порядке, не ждя завершения предыдущих. Для того чтобы эффективно использовать эту возможность в gRPC, вам нужно учитывать следующие аспекты:

Асинхронные вызовы: Воспользуйтесь асинхронным API gRPC для отправки запросов и получения ответов. Это позволит вашему клиенту или серверу не блокироваться во время ожидания ответа и обрабатывать другие задачи. В большинстве языков программирования, поддерживаемых gRPC (включая Go), есть поддержка асинхронных вызовов.

Клиентские потоки: Используйте клиентские потоковые RPC, если ваш клиент должен отправить серию сообщений на сервер, прежде чем получить ответ. В этом случае сервер может начать обработку данных, не дожидаясь окончания потока сообщений, что позволяет более эффективно использовать время обработки.

Серверные потоки: Аналогично, серверные потоковые RPC позволяют серверу отправлять клиенту серию сообщений по мере их обработки, не дожидаясь завершения всей операции.

Двунаправленное потоковое взаимодействие: Для максимального контроля и гибкости используйте двунаправленные потоковые RPC, которые позволяют клиенту и серверу одновременно отправлять серии сообщений друг другу, обеспечивая полное мултиплексирование.

Управление потоками на стороне клиента и сервера: Важно также учитывать управление ресурсами на клиенте и сервере, чтобы избежать перегрузки. Это может потребовать реализации логики управления потоками, например, ограничения количества одновременных вызовов или динамическое регулирование скорости отправки запросов в зависимости от текущей загрузки сервера.

Контекст и отмена операций: Используйте механизмы контекста для управления жизненным циклом RPC-вызовов, включая таймауты и отмену операций. Это позволит эффективно управлять ресурсами и предотвращать утечки.

Важно помнить, что хотя gRPC и HTTP/2 обеспечивают поддержку мултиплексирования, корректная и эффективная реализация зависит от правильного проектирования вашего приложения и управления ресурсами.