// Package main демонстрирует правила удовлетворения интерфейсов и приведения типов (type assertion)
// между разными интерфейсами в Go.
package main

import "fmt"

// Foo — это конкретный тип, который реализует методы A, B, и C.
type Foo struct{}

func (f *Foo) A() { fmt.Println("Метод A") }
func (f *Foo) B() { fmt.Println("Метод B") }
func (f *Foo) C() { fmt.Println("Метод C") }

// AB — это интерфейс, требующий методы A и B.
type AB interface {
	A()
	B()
}

// BC — это интерфейс, требующий методы B и C.
type BC interface {
	B()
	C()
}

func main() {
	// 1. Создаем переменную `f` с типом интерфейса `AB`.
	// Мы присваиваем ей значение типа `*Foo`. Это возможно, так как `*Foo`
	// реализует все методы интерфейса `AB` (у него есть методы A и B).
	//
	// Внутри `f` теперь находится пара: (тип: *Foo, значение: адрес экземпляра Foo).
	var f AB = &Foo{}
	fmt.Printf("Переменная 'f' имеет тип %T и содержит конкретный тип %T\n", f, f)
	f.A()
	f.B()

	fmt.Println("\n--- Выполняем приведение типов f.(BC) ---")
	// 2. Вопрос: сработает ли приведение типа f.(BC)?
	//
	// Ответ: ДА, сработает.
	// Приведение типа интерфейса `x.(T)` проверяет, удовлетворяет ли конкретное значение,
	// хранящееся в `x`, новому интерфейсу `T`.
	// В `f` хранится `*Foo`. Тип `*Foo` имеет методы A, B, и C, поэтому он
	// удовлетворяет и интерфейсу `BC` (которому нужны B и C).
	//
	// Паники не будет. Переменная `y` будет иметь тип `BC`, но внутри нее будет
	// по-прежнему храниться то же самое значение `*Foo`.
	y := f.(BC)

	fmt.Printf("Приведение типов успешно! Переменная 'y' теперь имеет тип %T и содержит тот же конкретный тип %T\n", y, y)
	y.B()
	y.C()

	fmt.Println("\n--- Пытаемся вызвать y.A() ---")
	// 3. Вопрос: можно ли теперь вызвать y.A()?
	//
	// Ответ: НЕТ, код не скомпилируется.
	// Хотя мы знаем, что под капотом в `y` лежит `*Foo`, у которого есть метод `A()`,
	// компилятор смотрит только на статичный тип переменной.
	// Тип переменной `y` — это `BC`. В интерфейсе `BC` метод `A()` не объявлен.
	// Поэтому компилятор выдаст ошибку: "y.A undefined (type BC has no field or method A)".

	// y.A() // <-- Эта строка вызовет ошибку компиляции.

	fmt.Println("Вызов y.A() невозможен, так как статичный тип переменной 'y' — это интерфейс BC, в котором нет метода A().")

	// Чтобы снова получить доступ к методу A(), нужно выполнить еще одно приведение типа:
	if z, ok := y.(AB); ok {
		fmt.Println("\nОбратное приведение `y` к типу `AB` успешно:")
		z.A()
	}
}
