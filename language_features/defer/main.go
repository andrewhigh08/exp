// Package main демонстрирует ключевые особенности работы `defer` в Go,
// а именно — момент вычисления аргументов для отложенной функции.
package main

import "fmt"

type Data struct {
	Value int
}

// SValue — метод с ресивером-значением.
// При вызове метода создается копия `d`.
func (d Data) SValue() {
	fmt.Printf("Ресивер-значение: d.Value = %d\n", d.Value)
}

// SPointer — метод с ресивером-указателем.
// При вызове метода передается указатель на `d`, копия не создается.
func (d *Data) SPointer() {
	fmt.Printf("Ресивер-указатель: d.Value = %d\n", d.Value)
}

// demo1_ValueReceiver демонстрирует, что ресивер-значение вычисляется (копируется)
// в момент объявления `defer`.
func demo1_ValueReceiver() {
	fmt.Println("--- Демо 1: Отложенный вызов метода с ресивером-значением ---")
	d := Data{Value: 100}

	// ПРАВИЛО: Аргументы отложенной функции (включая ресивер) вычисляются в момент вызова `defer`.
	// В данном случае, `d` является ресивером-значением, поэтому создается его копия
	// с `Value = 100`, и именно эта копия будет использована при выполнении `SValue()`.
	defer d.SValue()

	// Это изменение не повлияет на копию, созданную для `defer`.
	d.Value = 199

	fmt.Println("Значение d.Value в конце функции:", d.Value)
	// При выходе из функции будет напечатано 100.
}

// demo2_PointerReceiver демонстрирует, что ресивер-указатель также вычисляется
// в момент `defer`, но так как это указатель, он продолжает ссылаться на исходную переменную.
func demo2_PointerReceiver() {
	fmt.Println("\n--- Демо 2: Отложенный вызов метода с ресивером-указателем ---")
	d := &Data{Value: 200}

	// ПРАВИЛО: Аргумент `d` (который является указателем) вычисляется немедленно.
	// Копируется сам указатель, но он продолжает указывать на ту же область памяти.
	defer d.SPointer()

	// Мы изменяем данные по этому указателю.
	d.Value = 299

	fmt.Println("Значение d.Value в конце функции:", d.Value)
	// Когда `defer` сработает, он вызовет метод `SPointer` у оригинального объекта `d`
	// (по сохраненному указателю) и увидит измененное значение.
	// Будет напечатано 299.
}

// demo3_Closure демонстрирует, что функция-замыкание (closure) читает
// значение переменной в момент своего фактического выполнения.
func demo3_Closure() {
	fmt.Println("\n--- Демо 3: Отложенный вызов анонимной функции (замыкания) ---")
	d := Data{Value: 300}

	// ПРАВИЛО: Откладывается вызов самой анонимной функции. Код внутри нее
	// не выполняется до конца родительской функции.
	defer func() {
		// В момент выполнения этого кода, он обращается к переменной `d`
		// из внешней области видимости (замыкание) и видит ее *текущее* значение.
		fmt.Println("Вызов из замыкания:")
		d.SValue() // Вызовет SValue с d.Value = 399
	}()

	d.Value = 399

	fmt.Println("Значение d.Value в конце функции:", d.Value)
	// Будет напечатано 399.
}

func main() {
	demo1_ValueReceiver()
	demo2_PointerReceiver()
	demo3_Closure()
}
